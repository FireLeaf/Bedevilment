/* WARNING: This file has been autogenerated. Do not modify it directly! */

#ifndef XM_METHODIMPL_HPP
#define	XM_METHODIMPL_HPP

#include <XM/Exceptions/VariantCostnessException.hpp>

namespace xm{


template
<
    class ClassT,
    typename RetT
>
class MethodImpl_1_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    
    MethodImpl_1_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>()
            
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg1);
        (void)(arg2);
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT
>
class MethodImpl_1_Params
<
    ClassT,
    void
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    
    MethodImpl_1_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>()
            
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg1);
        (void)(arg2);
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1
>
class MethodImpl_2_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    
    MethodImpl_2_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg2);
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1
>
class MethodImpl_2_Params
<
    ClassT,
    void,
    ParamT1
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    
    MethodImpl_2_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg2);
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2
>
class MethodImpl_3_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    
    MethodImpl_3_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2
>
class MethodImpl_3_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    
    MethodImpl_3_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg3);
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3
>
class MethodImpl_4_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    
    MethodImpl_4_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3
>
class MethodImpl_4_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2,
    ParamT3
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    
    MethodImpl_4_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg4);
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4
>
class MethodImpl_5_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    
    MethodImpl_5_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4
>
class MethodImpl_5_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2,
    ParamT3,
    ParamT4
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    
    MethodImpl_5_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg5);
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5
>
class MethodImpl_6_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    
    MethodImpl_6_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5
>
class MethodImpl_6_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2,
    ParamT3,
    ParamT4,
    ParamT5
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    
    MethodImpl_6_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg6);
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5,
    typename ParamT6
>
class MethodImpl_7_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    typedef typename RemoveConst<typename RemoveReference<ParamT6>::Type>::Type
        NqParamT6;
    
    MethodImpl_7_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5,
            ParamT6
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>(),
            getType<ParamT6>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>(),
            arg6.as<NqParamT6>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5,
        ParamT6
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5,
    typename ParamT6
>
class MethodImpl_7_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2,
    ParamT3,
    ParamT4,
    ParamT5,
    ParamT6
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    typedef typename RemoveConst<typename RemoveReference<ParamT6>::Type>::Type
        NqParamT6;
    
    MethodImpl_7_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5,
            ParamT6
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>(),
            getType<ParamT6>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        (void)(arg7);
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>(),
            arg6.as<NqParamT6>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5,
        ParamT6
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename RetT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5,
    typename ParamT6,
    typename ParamT7
>
class MethodImpl_8_Params : public Method
{
public: 
    /// type of the return value without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<RetT>::Type>::Type
        NqRetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    typedef typename RemoveConst<typename RemoveReference<ParamT6>::Type>::Type
        NqParamT6;
    typedef typename RemoveConst<typename RemoveReference<ParamT7>::Type>::Type
        NqParamT7;
    
    MethodImpl_8_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5,
            ParamT6,
            ParamT7
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>(),
            getType<ParamT6>(),
            getType<ParamT7>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        if (IsReference<RetT>::value)
        {
            if (IsConst<RetT>::value)
                return ConstReference;
            else
                return Reference;
        }
        else
            return Value;
    }
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        const NqRetT& returnValue = (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>(),
            arg6.as<NqParamT6>(),
            arg7.as<NqParamT7>()
        );
        return Variant(const_cast<NqRetT&>(returnValue),
                ReturnVariantFlags<RetT>::flags);
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5,
        ParamT6,
        ParamT7
    );

    /// Whether the method is constant.
    bool constant_;
};


template
<
    class ClassT,
    typename ParamT1,
    typename ParamT2,
    typename ParamT3,
    typename ParamT4,
    typename ParamT5,
    typename ParamT6,
    typename ParamT7
>
class MethodImpl_8_Params
<
    ClassT,
    void,
    ParamT1,
    ParamT2,
    ParamT3,
    ParamT4,
    ParamT5,
    ParamT6,
    ParamT7
> : public Method
{
public: 
        typedef void RetT;

    /// type of the arguments without any cv-qualifier and no reference
    typedef typename RemoveConst<typename RemoveReference<ParamT1>::Type>::Type
        NqParamT1;
    typedef typename RemoveConst<typename RemoveReference<ParamT2>::Type>::Type
        NqParamT2;
    typedef typename RemoveConst<typename RemoveReference<ParamT3>::Type>::Type
        NqParamT3;
    typedef typename RemoveConst<typename RemoveReference<ParamT4>::Type>::Type
        NqParamT4;
    typedef typename RemoveConst<typename RemoveReference<ParamT5>::Type>::Type
        NqParamT5;
    typedef typename RemoveConst<typename RemoveReference<ParamT6>::Type>::Type
        NqParamT6;
    typedef typename RemoveConst<typename RemoveReference<ParamT7>::Type>::Type
        NqParamT7;
    
    MethodImpl_8_Params(const std::string& uName,
        RetT (ClassT::*method)
        (
            ParamT1,
            ParamT2,
            ParamT3,
            ParamT4,
            ParamT5,
            ParamT6,
            ParamT7
        ),
        bool constant = false) :
        Item(uName, getClass<ClassT>()),
        Method(
            uName,
            getType<RetT>(),
            getClass<ClassT>(),
            getType<ParamT1>(),
            getType<ParamT2>(),
            getType<ParamT3>(),
            getType<ParamT4>(),
            getType<ParamT5>(),
            getType<ParamT6>(),
            getType<ParamT7>()
        ),
        method_(method),
        constant_(constant)
    {
    }

    
    Function::ReturnMode getReturnMode() const
    {
        return None;
    }
    
    
    bool isConst() const
    {
        return constant_;
    }
    
    
    Variant callImpl
    (   
        Variant& arg0,
        Variant& arg1,
        Variant& arg2,
        Variant& arg3,
        Variant& arg4,
        Variant& arg5,
        Variant& arg6,
        Variant& arg7
        
    ) const
    {   
        
        // cannot call a non constant method of a constant instance
        if (arg0.isConst() && !constant_)
            throw VariantCostnessException(arg0.getType());
        
        (arg0.as<ClassT>().*method_)
        (
            arg1.as<NqParamT1>(),
            arg2.as<NqParamT2>(),
            arg3.as<NqParamT3>(),
            arg4.as<NqParamT4>(),
            arg5.as<NqParamT5>(),
            arg6.as<NqParamT6>(),
            arg7.as<NqParamT7>()
        );
        return Variant::Void;
        
    }

private:
    RetT (ClassT::*method_)
    (
        ParamT1,
        ParamT2,
        ParamT3,
        ParamT4,
        ParamT5,
        ParamT6,
        ParamT7
    );

    /// Whether the method is constant.
    bool constant_;
};



} // namespace xm

#endif /* XM_METHODIMPL_HPP */